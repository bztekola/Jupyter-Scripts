# Libraries
```{r}
library(readxl)
library(tools)
library(gtools)
library(forecast)
library(dplyr)
library(lubridate)
library(openxlsx)
library(stringr)
```

# Script settings
```{r}
excel_write <- 'no'
forecast_steps <- 2

read_path <- '/Users/jarad/Fake\ Folder/Fab/Projects/War\ Chest\ 2018/CSVs/'
write_path <- '/Users/jarad/Fake\ Folder/Fab/Projects/War\ Chest\ 2018/R/'
```

# Get data
```{r}
excluded <- read_excel(paste(read_path,'Excluded\ Parts.xlsx', sep = ''))
colnames(excluded) <- str_replace_all(colnames(excluded), ' ', '_')

main <- read_excel(paste(read_path,'War\ Chest\ Part\ sales\ for\ R.xlsx', sep = ''))
colnames(main) <- str_replace_all(colnames(main), ' ', '_')

main$year_and_month <- as.Date(main$year_and_month)
```

# Check out unique part id count
```{r}
l <- length(unique(main$part_id))
print(paste('the unique (umbrella) part id count is', l))
```

# Define models
```{r}
naive_func <- function(t1, forecast_steps){
  model <- rwf(t1, h = forecast_steps, level = c(95))
  model_counter <- 1
  ret = list('model' = model, 'model_counter' = model_counter)
  return(ret)
}

ses_func <- function(t1, forecast_steps){
  model <- ses(t1, h = forecast_steps, level = c(95))
  model_counter <- 1
  ret = list('model' = model, 'model_counter' = model_counter)
  return(ret)
}

arima_func <- function(t1, forecast_steps){
  trace <- capture.output({
    m1 <- auto.arima(t1, trace = TRUE)
    model <- forecast(m1, h = forecast_steps, level = c(95))
  })
con    <- textConnection(trace)
models <- read.table(con, sep=":")
model_counter <- length(models[,1]) - 1
close(con)
ret <- list('model' = model, 'model_counter' = model_counter)
  return(ret)
}

holt_func <- function(t1, forecast_steps){
  model_counter <- 0
  sse <- Inf
  for (w in list('additive','multiplicative')){
    for (beta in list(TRUE,FALSE)){
      for (gamma in list(TRUE,FALSE)){
        tryCatch({
          model_counter <- model_counter + 1
          m1 <- HoltWinters(t1, season = c(w), beta = beta, gamma = gamma)
          if (m1$SSE < sse){
            sse <- m1$SSE
            model <- forecast(m1, h = forecast_steps, level = c(95))
          }
        }, error = function(e){})
      }
    }
  }
  ret = list('model' = model, 'model_counter' = model_counter)
  return(ret)
}  
```

# Put each part through each model
# Choose the best model per part based on the RMSE
```{r}
# get a list of all unique part numbers
all_pns <- unique(main$part_id)

# get date of first forecast through last forecast
d <- max(main$year_and_month)
d <- as.Date(d) + months(1)
ds <- seq(as.Date(d), by = 'month', length.out = forecast_steps)

# just year_and_month
d1 <- substring(ds[1], 1,7)
d2 <- substring(ds[length(ds)], 1,7)

# empty df to store results
final_models <- data.frame(matrix(nrow = 0, ncol = 8))

start <- Sys.time()

# prepare counters and lists
total_models <- 0
total_pns <- 0
final_models <- list()

models <- c(naive_func, 
            ses_func,
            arima_func,
            holt_func)

# loop through all PNs
for (pn in all_pns){
  total_pns <- total_pns + 1
  model_counter <- 0
  
  # prepare data for model building; split into training and test sets
  df <- subset(main, part_id == pn)

  n = ceiling(nrow(df) * 0.80)
  train_data <- df[1:n,]
  test_data <- df[(n+1):nrow(df),]
  
  train <- train_data$qty_total
  test <- test_data$qty_total
  
  steps <- length(test)
  RMSE <- Inf
  
  tryCatch({
  # loop through each model and choose the best
  for (i in 1:length(models)){
    m <- models[[i]]
    
    # fit the model to the training set
    fit <- m(train, steps)
    total_models <- total_models + fit$model_counter
    
    # get the rmse
    rmse <- accuracy(fit$model, test)[4]
    
    # if the rmse is the lowest then choose that model
    if (rmse < RMSE){
      RMSE <- rmse
      m2 <- m
      }
    }
  }, error = function(e){})
  
  # send all data through the best model and forecast over the unknown future
  f <- m2(df$qty_total, forecast_steps)
  
  # construct dataframe for PN
  model_used <- f$model$method
  mape <- accuracy(f$model)[5]
  mae <- accuracy(f$model)[3]  
  
  df2 <- as.data.frame(f$model)
  
  colnames(df2)[colnames(df2) == 'Lo 95'] <- 'lower'
  df2$lower[df2$lower < 0] <- 0
  colnames(df2)[colnames(df2) == 'Point Forecast'] <- 'avg'
  colnames(df2)[colnames(df2) == 'Hi 95'] <- 'upper'
  
  for (c in c('lower','avg','upper')) {
    df2[c] <- round(df2[c])
  }
  
  df2$part_id <- pn
  df2$forecast_month <- ds
  df2$model_used <- model_used
  df2$mape <- (round(mape,2))/100
  df2$mae <- round(mae)
  
  # bind it with the rest
  final_models <- rbind(final_models, df2)
}

end <- Sys.time()
end - start
print(paste(round(total_models/total_pns),'models per PN on avg'))
```

# Make sure you made a model for every PN
```{r}
v1 <- length(unique(final_models$part_id))
v2 <- length(all_pns)

if (v1 != v2){
  stop('mismatch')
}
```

# Check out avg MAPE and MAE over all models
```{r}
summary(final_models[,c('mae','mape')])
```

# Prep part data for join
```{r}
ls <- colnames(main)
drop <- c('year_and_month',
          'qty_total',
          'sku_id',
          'sku_date_modified')
ls <- ls[!ls %in% drop]

part_data <- main[ls]
part_data <- unique(part_data)
```

# Join part data to final models
```{r}
final_models <- merge(final_models, part_data, by = 'part_id', all.x = TRUE)
```

# Start building Excel workbook
# We create one workbook per BOM type, with tabs that go like this:
  # Tab01: Model Summary
  # Tab02 - 06: Estimates per popularity tier
  # Tab07: Parts Excluded

```{r}
boms <- unique(final_models$bom_type)
pops <- pops <- final_models$popularity_tier %>% 
        unique() %>% 
        mixedsort()
dates <- unique(final_models$forecast_month)

for (b in boms){
  
  if (b == 'pnp') {
    title <- paste('Fab War Chest 2018 Forecasts for ',d1,' to ',d2, sep = '')
  } else {
    title <- paste('Kitting War Chest 2018 Forecasts for ',d1,' to ',d2, sep = '')
  }
  
#=========================
# Tab01: Model Summaries
#=========================  
  
  cols <- c('part_id',
            'mape',
            'mae',
            'model_used',
            'bom_type',
            'popularity_tier',
            'outsourced')
  
  df <- unique(final_models[cols])
  df <- arrange(df, popularity_tier, part_id)
  df <- subset(df, bom_type == b)
  colnames(df) <- str_replace_all(colnames(df), '_', ' ')
  
  worksheet_ls <- list('Model Summaries' = df)
  
#=========================
# Tab02 - 06: Forecasts per part per month, where each popularity tier gets its own worksheet
#=========================    
  
  cols <- c('part_id',
            'bom_type',
            'popularity_tier',
            'forecast_month',
            'lower',
            'avg',
            'upper',
            'outsourced')
  
  df <- final_models[cols]
  df <- subset(df, bom_type == b)
  df <- arrange(df, popularity_tier, part_id)
  
  df$forecast_month <- substr(df$forecast_month, 1, 7)

  # segment by popularity tier
  for (p in pops) {
    df2 <- subset(df, popularity_tier == p)
    colnames(df2) <- str_replace_all(colnames(df2), '_', ' ')
    
    worksheet_ls[[p]] <- df2
  }
  
#=========================
# Tab07: Parts Excluded
#=========================        
  
  df <- subset(excluded, bom_type == b)
  worksheet_ls[['Parts Excluded']] <- df
  
#=========================
# Make everything look nicer
#=========================  
  
  name <- names(worksheet_ls)
  i <- 1
  
  for (w in worksheet_ls) {
    colnames(w) <- str_replace_all(colnames(w), '_',' ')
    colnames(w) <- colnames(w) %>% toTitleCase()
    
    for (c in colnames(w)) {
      if (class(w[[c]]) == 'character') {
        w[[c]] <- w[[c]] %>% toTitleCase()
      }
    }
    
    worksheet_ls[[name[i]]] <- w
    i <- i + 1
    
  }  
  
#=========================
# Write it all to excel
#=========================      
  
  if (excel_write == 'yes') {
    write.xlsx(worksheet_ls, file = paste(write_path, title,'.xlsx'))  
  }
}
```

```{r}
print('done')
```

