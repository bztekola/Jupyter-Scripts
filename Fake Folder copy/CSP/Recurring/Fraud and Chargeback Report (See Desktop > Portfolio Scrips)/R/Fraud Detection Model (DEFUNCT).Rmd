# Confusion Matrix
# https://www.rdocumentation.org/packages/caret/versions/6.0-81/topics/confusionMatrix

# Time the whole thing
```{r}
script_time_start <- Sys.time()
```

# Libraries
```{r}
options(repos = 'http://cran.rstudio.com/')

library(readxl)
library(plyr)
library(tidyverse)
library(caret)
library(GGally)
library(stringr)
library(rattle)
library(pROC)
library(ROCR)
library(iterators)
library('e1071')
library(randomForest)
library(rattle)
library(kernlab)
```

# Get data
```{r}
csv_path <- '/Users/jarad/Fake Folder/CSP/Recurring/Fraud and Chargeback Report/CSVs/Fraud Detection Data for R.xlsx'
main <- read_excel(csv_path)
colnames(main) <- str_replace_all(colnames(main), ' ', '_')
```

# Fraud vs not-fraud plot
```{r}
for_chart <- main
max <- summary(for_chart$order_subtotal)['3rd Qu.']

ggplot(for_chart, aes(x = order_subtotal, color = fraud)) + 
  geom_density() +
  xlim(-25,500) +
  ggtitle('Density Plot for Order Totals per Fraud Group')
```

# Drop some columns
```{r}
ls <- list('ip_mismatch',
'fraud',
'fraud_before',
'hotel',
'order_subtotal_bins',
'matching_postcodes',
'us_and_non',
'repeat_customer',
'email_domain_clean',
'contains_top_part',
'ip_flaged_before')

main <- main[, colnames(main) %in% ls]
```

# Change characters to factors
```{r}
cols <- colnames(main)
ls <- list()

i <- 1
for (c in cols){
  if (class(main[[c]]) == 'character'){
    ls[i] <- c
    i <- i+1
  }
}

for (c in ls){
  main[[c]] <- as.factor(main[[c]])
}
```

# Check out correlations, and remove variables that are highly correlated
```{r}
for_cor <- main
for_cor[] <- lapply(main, as.integer)
cor_table <- cor(for_cor)
print(cor_table > 0.5)

# "fraud_before" and "fraud" are highly correlated; remove "fraud_before"
main <- main[, colnames(main) != 'fraud_before']
```

# Just fraud
```{r}
fraud <- filter(main, main$`fraud` == 'yes')
```

#==================================================
# Create balanced training set
# We do this because fraud and not-fraud proportions are very imbalanced
# https://datascience.stackexchange.com/questions/810/should-i-go-for-a-balanced-dataset-or-a-representative-dataset
#==================================================

# Undersample non fraud
```{r}
#n <- nrow(fraud_main)
#df <- filter(main, fraud == 'no')

#set.seed(1)
#sample_ix <- sample(1:nrow(df),n)

#not_fraud <- df[sample_ix,]
#sample_set <- rbind(fraud_main, not_fraud)
```

# Oversample fraud
```{r}
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n3 <- round(n1/n2)

oversampled_fraud <- fraud
for (i in seq(1,n3-1)) {
  oversampled_fraud <- rbind(oversampled_fraud, fraud)
}

new_main <- rbind(subset(main, fraud == 'no'), oversampled_fraud)
table(new_main$fraud)
```

# Create sample set which is half fraud and half not-fraud, and which is smaller than new main
```{r}
div <- 10

set.seed(1)
a <- subset(new_main, fraud == 'no')
n <- round(nrow(a)/div)
ix <- sample(seq(1,n))
not_fraud_for_sample_set <- a[ix,]

set.seed(2)
a <- subset(new_main, fraud == 'yes')
n <- round(nrow(a)/div)
ix <- sample(seq(1,n))
fraud_for_sample_set <- a[ix,]

sample_set <- rbind(not_fraud_for_sample_set, fraud_for_sample_set)

# shuffle sample set
set.seed(3)
ix <- sample(seq(1:nrow(sample_set)))

sample_set <- sample_set[ix,]
```

# Split into training and test set
```{r}
n <- floor(nrow(sample_set) * 0.80)

train_set <- sample_set[1:n, ]
test_set <- sample_set[-n, ]
```

# Create control used to fit all models
```{r}
control <- trainControl(method = 'repeatedcv', # repeated cross validation
                        number = 10, # 10 folds
                        repeats = 3, # 3 iterations
                        classProbs = TRUE, 
                        summaryFunction = twoClassSummary)
```


# Create empty list to hold all models
```{r}
models <- list()
```

#==================================================
# Recursive Partitioning
#==================================================
```{r}
start_time <- Sys.time()
rpart_model = train(fraud ~ .,
                    data = train_set,
                    method = 'rpart',
                    tuneLength = 10,
                    metric = 'ROC',
                    trControl = control, 
                    parms = list(split = 'information'),
                    minsplit = 1)
end_time <- Sys.time()
end_time - start_time

models[['rpart']] <- rpart_model
```

#==================================================
# C5.0 Model
# Decision trees and rule-based models for pattern recognition
#==================================================
```{r}
#to create a data frame from all combinations of the supplied vectors or factors
grid <- expand.grid( .winnow = c(FALSE,TRUE), 
                     .trials = c(1, 25, 50, 100),
                     .model = 'tree')

start_time <- Sys.time()
suppressWarnings(
  c5_model <- train(fraud ~ .,
                  data = train_set, 
                  method = 'C5.0',
                  trControl = control, 
                  metric = 'ROC',
                  tuneGrid = grid, 
                  verbose = FALSE)
)
end_time <- Sys.time()
end_time - start_time

models[['c5']] <- c5_model
```

#==================================================
# Random Forest Model
# Ensemble Learning (a combo of decision tree many models such that over- and under-fitting are reduced)
#==================================================

```{r}
grid <- expand.grid(.mtry = 5, .ntree = seq(25, 150, by = 25))

start_time <- Sys.time()
rf_model <- train(fraud ~ ., 
                  data = train_set, 
                  method = 'rf', 
                  metric = 'ROC', 
                  TuneGrid = grid, 
                  trControl = control)
end_time <- Sys.time()
end_time - start_time

models[['rf']] <- rf_model
```

#==================================================
# Support Vector Machine
# A data classification method that separates data using hyperplanes
#==================================================

```{r}
start_time <- Sys.time()
suppressWarnings(
svm_model <- train(fraud ~ ., 
                  data = train_set, 
                  method = 'svmRadial',   # Radial kernel
                  tuneLength = 3,  # 3 values of the cost function
                  metric = 'ROC',
                  trControl = control)
)
end_time <- Sys.time()
end_time - start_time

models[['svm']] <- svm_model
```

#==================================================
# Predict on training set
#==================================================

```{r}
results <- list()
new_data <- train_set
suffix <- '_train'

for (n in names(models)) {
  m <- models[[n]]
  res <- predict(m, new_data, cutoff = 0.75)
  results[[paste(n, suffix, sep = '')]] <- res
}

do_this <- 'yes'

if (do_this == 'yes') {
  for (n in names(results)) {
    
    print(n)
    
    # confusion matrix
    cm <- confusionMatrix(results[[n]], new_data$fraud, positive = 'yes')
    print(cm)
    
    # ROC
    model_name <- strsplit(n, '_')[[1]][1]
    probs <- predict(models[[model_name]], new_data, type = 'prob')
    roc <- roc(response = new_data$fraud, 
               predictor = probs$yes, 
               levels = levels(new_data$fraud))
    plot(roc)
    title(model_name)
    
  }  
}
```

#==================================================
# Predict on test set
#==================================================
```{r}
results <- list()
new_data <- test_set
suffix <- '_test'

for (n in names(models)) {
  m <- models[[n]]
  res <- predict(m, new_data)
  results[[paste(n, suffix, sep = '')]] <- res
}

do_this <- 'yes'

if (do_this == 'yes') {
  for (n in names(results)) {
    
    print(n)
    
    # confusion matrix
    cm <- confusionMatrix(results[[n]], new_data$fraud, positive = 'yes')
    print(cm)
    
    # ROC
    model_name <- strsplit(n, '_')[[1]][1]
    probs <- predict(models[[model_name]], new_data, type = 'prob')
    roc <- roc(response = new_data$fraud, 
               predictor = probs$yes, 
               levels = levels(new_data$fraud))
    plot(roc)
    title(model_name)
    
  }  
}
```
#==================================================
# Predict on all data
#==================================================

```{r}
start <- Sys.time()

results <- list()
new_data <- main
suffix <- '_all'

for (n in names(models)) {
  m <- models[[n]]
  res <- predict(m, new_data)
  results[[paste(n, suffix, sep = '')]] <- res
}

do_this <- 'yes'

if (do_this == 'yes') {
  for (n in names(results)) {
    
    print(n)
    
    # confusion matrix
    cm <- confusionMatrix(results[[n]], new_data$fraud, positive = 'yes')
    print(cm)
    
    # ROC
    model_name <- strsplit(n, '_')[[1]][1]
    probs <- predict(models[[model_name]], new_data, type = 'prob')
    roc <- roc(response = new_data$fraud, 
               predictor = probs$yes, 
               levels = levels(new_data$fraud))
    plot(roc)
    title(model_name)
    
  }  
}

end <- Sys.time()
end - start
```
```{r}
script_time_end <- Sys.time()
script_time_end - script_time_start
```