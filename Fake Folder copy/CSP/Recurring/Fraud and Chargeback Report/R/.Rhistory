table(predict(rpart_model, type = 'prob')[,'yes'] >= cutoff, train_set$fraud == 'yes')
cutoff = 0.65
cm <- table(predict(rpart_model, type = 'prob')[,'yes'] >= cutoff, train_set$fraud == 'yes')
confusionMatrix(cm)
cutoff = 0.50
cm <- table(predict(rpart_model, type = 'prob')[,'yes'] >= cutoff, train_set$fraud == 'yes')
confusionMatrix(cm)
results <- list()
new_data <- train_set
suffix <- '_train'
for (n in names(models)) {
m <- models[[n]]
res <- predict(m, new_data, cutoff = 0.75)
results[[paste(n, suffix, sep = '')]] <- res
}
do_this <- 'yes'
if (do_this == 'yes') {
for (n in names(results)) {
print(n)
# confusion matrix
cm <- confusionMatrix(results[[n]], new_data$fraud, positive = 'yes')
print(cm)
# ROC
model_name <- strsplit(n, '_')[[1]][1]
probs <- predict(models[[model_name]], new_data, type = 'prob')
roc <- roc(response = new_data$fraud,
predictor = probs$yes,
levels = levels(new_data$fraud))
plot(roc)
title(model_name)
}
}
train_results <- results
train_results$rpart_train
confusionMatrix(train_results$rpart_train)
confusionMatrix(train_results$rpart_train, train_set)
confusionMatrix(train_results$rpart_train, train_set$fraud)
cutoff = 0.50
cm <- table(predict(rpart_model, type = 'prob')[,'yes'] >= cutoff, train_set$fraud)
confusionMatrix(cm)
cutoff = 0.50
cm <- table(predict(rpart_model, type = 'prob')[,'yes'] >= cutoff, train_set$fraud == 'yes')
confusionMatrix(cm)
cutoff = 0.75
cm <- table(predict(rpart_model, type = 'prob')[,'yes'] >= cutoff, train_set$fraud == 'yes')
confusionMatrix(cm)
cutoff = 0.80
cm <- table(predict(rpart_model, type = 'prob')[,'yes'] >= cutoff, train_set$fraud == 'yes')
confusionMatrix(cm)
cutoff = 0.10
cm <- table(predict(rpart_model, type = 'prob')[,'yes'] >= cutoff, train_set$fraud == 'yes')
confusionMatrix(cm)
rpart_model
summary(rpart_model)
# undersampling non fraud
#n <- nrow(fraud_main)
#df <- filter(main, fraud == 'no')
#set.seed(1)
#sample_ix <- sample(1:nrow(df),n)
#not_fraud <- df[sample_ix,]
#sample_set <- rbind(fraud_main, not_fraud)
# oversampling fraud
nrow(main)
#n <- nrow(fraud_main)
#df <- filter(main, fraud == 'no')
#set.seed(1)
#sample_ix <- sample(1:nrow(df),n)
#not_fraud <- df[sample_ix,]
#sample_set <- rbind(fraud_main, not_fraud)
nrow(main$fraud == 'no')
nrow(subset(main, fraud == 'no'))
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n1,n2
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n1
n2
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n1 n2
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n1
n2
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n1/n2
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
round(n1/n2)
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n3 <- round(n1/n2)/2
n3
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n3 <- round(n1/n2/2)
n3
fraud <- filter(main, main$`fraud` == 'yes')
fraud <- filter(main, main$`fraud` == 'yes')
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n3 <- round(n1/n2/2)
fraud
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n3 <- round(n1/n2/2)
fraud * 10
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n3 <- round(n1/n2/2)
fraud
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n3 <- round(n1/n2/2)
n3 <- 3
oversampled_fraud <- fraud
for (i in seq(1,n3)) {
print(i)
}
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n3 <- round(n1/n2/2)
n3 <- 3
oversampled_fraud <- fraud
for (i in seq(1,n3)) {
oversampled_fraud <- rbind(oversampled_fraud, fraud)
}
nrow(fraud)
nrow(fraud)
nrow(oversampled_fraud)
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n3 <- round(n1/n2/2)
n3 <- 3
oversampled_fraud <- fraud
for (i in seq(1,n3-1)) {
oversampled_fraud <- rbind(oversampled_fraud, fraud)
}
nrow(fraud)
nrow(oversampled_fraud)
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n3 <- round(n1/n2/2)
oversampled_fraud <- fraud
for (i in seq(1,n3-1)) {
oversampled_fraud <- rbind(oversampled_fraud, fraud)
}
nrow(fraud)
nrow(oversampled_fraud)
set.seed(1)
not_fraud <- sample(subset(main, fraud == 'no'), n3)
n1
n1
n3
n1
nrow(oversampled_fraud)
set.seed(1)
not_fraud <- sample(subset(main, fraud == 'no'), nrow(oversampled_fraud))
n1 <- nrow(subset(main, fraud == 'no'))
n1
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n1
n2
n1
n2
n1/n2
n1
n2
round(n1/n2)
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n3 <- round(n1/n2)
oversampled_fraud <- fraud
for (i in seq(1,n3-1)) {
oversampled_fraud <- rbind(oversampled_fraud, fraud)
}
sample_set <- rbind(subset(main, fraud == 'no'), oversampled_fraud)
table(sample_set$fraud)
n <- floor(nrow(sample_set) * 0.80)
set.seed(1)
ix <- sample(seq_len(nrow(sample_set)), size = n) # shuffle the sample_set
train_set <- sample_set[ix, ]
test_set <- sample_set[-ix, ]
control <- trainControl(method = 'repeatedcv', # repeated cross validation
number = 10, # 10 folds
repeats = 3, # 3 iterations
classProbs = TRUE,
summaryFunction = twoClassSummary)
models <- list()
start_time <- Sys.time()
rpart_model = train(fraud ~ .,
data = train_set,
method = 'rpart',
tuneLength = 10,
metric = 'Accuracy',
trControl = control,
parms = list(split = 'information'),
minsplit = 1)
nrow(train_set)
nrow(train_set)
nrow(main)
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n3 <- round(n1/n2)
oversampled_fraud <- fraud
for (i in seq(1,n3-1)) {
oversampled_fraud <- rbind(oversampled_fraud, fraud)
}
sample_set <- rbind(subset(main, fraud == 'no'), oversampled_fraud)
table(sample_set$fraud)
nrow(sample_set)
nrow(sample_set)/2
nrow(sample_set)/4
sample(sample_set, nrow(sample_set)/4)
sample(sample_set, (nrow(sample_set)/4))
sample(sample_set, 1)
head(sample_set)
new_main <- sample_set
table(new_main$fraud)
set.seed(1)
a <- subset(new_main, fraud == 'no')
nrow(a)
set.seed(1)
a <- subset(new_main, fraud == 'no')
nrow(a)/4
set.seed(1)
a <- subset(new_main, fraud == 'no')
nrow(a)/10
set.seed(1)
a <- subset(new_main, fraud == 'no')
n <- round(nrow(a)/10)
n
set.seed(1)
a <- subset(new_main, fraud == 'no')
n <- round(nrow(a)/10)
ix <- sample(seq(1,n))
ix
set.seed(1)
div <- 10
a <- subset(new_main, fraud == 'no')
n <- round(nrow(a)/div)
ix <- sample(seq(1,n))
not_fraud_for_sample_set <- a[ix,]
for_cor <- main
for_cor[] <- lapply(main, as.integer)
cor_table <- cor(for_cor)
print(cor_table > 0.5)
# "fraud_before" and "fraud" are highly correlated; remove "fraud_before"
main <- main[, colnames(main) != 'fraud_before']
fraud <- filter(main, main$`fraud` == 'yes')
script_time_start <- Sys.time()
options(repos = 'http://cran.rstudio.com/')
library(readxl)
library(plyr)
library(tidyverse)
library(caret)
library(GGally)
library(stringr)
library(rattle)
library(pROC)
library(ROCR)
library(iterators)
library('e1071')
library(randomForest)
library(rattle)
library(kernlab)
csv_path <- '/Users/jarad/Fake Folder/CSP/Recurring/Fraud and Chargeback Report/CSVs/Fraud Detection Data for R.xlsx'
main <- read_excel(csv_path)
colnames(main) <- str_replace_all(colnames(main), ' ', '_')
for_chart <- main
max <- summary(for_chart$order_subtotal)['3rd Qu.']
ggplot(for_chart, aes(x = order_subtotal, color = fraud)) +
geom_density() +
xlim(-25,500) +
ggtitle('Density Plot for Order Totals per Fraud Group')
ls <- list('ip_mismatch',
'fraud',
'fraud_before',
'hotel',
'order_subtotal_bins',
'matching_postcodes',
'us_and_non',
'repeat_customer',
'email_domain_clean',
'contains_top_part',
'ip_flaged_before')
main <- main[, colnames(main) %in% ls]
cols <- colnames(main)
ls <- list()
i <- 1
for (c in cols){
if (class(main[[c]]) == 'character'){
ls[i] <- c
i <- i+1
}
}
for (c in ls){
main[[c]] <- as.factor(main[[c]])
}
for_cor <- main
for_cor[] <- lapply(main, as.integer)
cor_table <- cor(for_cor)
print(cor_table > 0.5)
# "fraud_before" and "fraud" are highly correlated; remove "fraud_before"
main <- main[, colnames(main) != 'fraud_before']
fraud <- filter(main, main$`fraud` == 'yes')
#n <- nrow(fraud_main)
#df <- filter(main, fraud == 'no')
#set.seed(1)
#sample_ix <- sample(1:nrow(df),n)
#not_fraud <- df[sample_ix,]
#sample_set <- rbind(fraud_main, not_fraud)
n1 <- nrow(subset(main, fraud == 'no'))
n2 <- nrow(subset(main, fraud == 'yes'))
n3 <- round(n1/n2)
oversampled_fraud <- fraud
for (i in seq(1,n3-1)) {
oversampled_fraud <- rbind(oversampled_fraud, fraud)
}
new_main <- rbind(subset(main, fraud == 'no'), oversampled_fraud)
table(new_main$fraud)
models <- list()
set.seed(1)
div <- 10
a <- subset(new_main, fraud == 'no')
n <- round(nrow(a)/div)
ix <- sample(seq(1,n))
not_fraud_for_sample_set <- a[ix,]
a
a
n
a
n
nrow(main)
div <- 10
set.seed(1)
a <- subset(new_main, fraud == 'no')
n <- round(nrow(a)/div)
ix <- sample(seq(1,n))
not_fraud_for_sample_set <- a[ix,]
set.seed(2)
a <- subset(new_main, fraud == 'yes')
n <- round(nrow(a)/div)
ix <- sample(seq(1,n))
fraud_for_sample_set <- a[ix,]
sample_set <- rbind(not_fraud_for_sample_set, fraud_for_sample_set)
nrow(sample_set)
set.seed(3)
ix <- sample(seq(1:nrow(sample_set)))
set.seed(3)
ix <- sample(seq(1:nrow(sample_set)))
ix
set.seed(4)
ix <- sample(seq(1:nrow(sample_set)))
ix
set.seed(3)
ix <- sample(seq(1:nrow(sample_set)))
ix
set.seed(3)
ix <- sample(seq(1:nrow(sample_set)))
# shuffle sample set
sample_set <- sample_set[ix,]
sample_set
n <- floor(nrow(sample_set) * 0.80)
train_set <- sample_set[ix, ]
test_set <- sample_set[-ix, ]
nrow(train_set)
nrow(test_set)
n <- floor(nrow(sample_set) * 0.80)
train_set <- sample_set[n, ]
test_set <- sample_set[-n, ]
nrow(train_set)
nrow(main)
n <- floor(nrow(sample_set) * 0.80)
train_set <- sample_set[1:n, ]
test_set <- sample_set[-n, ]
nrow(train_set)
nrow(main)
nrow(train_set)
nrow(test_set)
n
control <- trainControl(method = 'repeatedcv', # repeated cross validation
number = 10, # 10 folds
repeats = 3, # 3 iterations
classProbs = TRUE,
summaryFunction = twoClassSummary)
models <- list()
start_time <- Sys.time()
rpart_model = train(fraud ~ .,
data = train_set,
method = 'rpart',
tuneLength = 10,
metric = 'Accuracy',
trControl = control,
parms = list(split = 'information'),
minsplit = 1)
end_time <- Sys.time()
end_time - start_time
models[['rpart']] <- rpart_model
results <- list()
new_data <- train_set
suffix <- '_train'
for (n in names(models)) {
m <- models[[n]]
res <- predict(m, new_data, cutoff = 0.75)
results[[paste(n, suffix, sep = '')]] <- res
}
do_this <- 'yes'
if (do_this == 'yes') {
for (n in names(results)) {
print(n)
# confusion matrix
cm <- confusionMatrix(results[[n]], new_data$fraud, positive = 'yes')
print(cm)
# ROC
model_name <- strsplit(n, '_')[[1]][1]
probs <- predict(models[[model_name]], new_data, type = 'prob')
roc <- roc(response = new_data$fraud,
predictor = probs$yes,
levels = levels(new_data$fraud))
plot(roc)
title(model_name)
}
}
results <- list()
new_data <- test_set
suffix <- '_test'
for (n in names(models)) {
m <- models[[n]]
res <- predict(m, new_data)
results[[paste(n, suffix, sep = '')]] <- res
}
do_this <- 'yes'
if (do_this == 'yes') {
for (n in names(results)) {
print(n)
# confusion matrix
cm <- confusionMatrix(results[[n]], new_data$fraud, positive = 'yes')
print(cm)
# ROC
model_name <- strsplit(n, '_')[[1]][1]
probs <- predict(models[[model_name]], new_data, type = 'prob')
roc <- roc(response = new_data$fraud,
predictor = probs$yes,
levels = levels(new_data$fraud))
plot(roc)
title(model_name)
}
}
start <- Sys.time()
results <- list()
new_data <- main
suffix <- '_all'
for (n in names(models)) {
m <- models[[n]]
res <- predict(m, new_data)
results[[paste(n, suffix, sep = '')]] <- res
}
do_this <- 'yes'
if (do_this == 'yes') {
for (n in names(results)) {
print(n)
# confusion matrix
cm <- confusionMatrix(results[[n]], new_data$fraud, positive = 'yes')
print(cm)
# ROC
model_name <- strsplit(n, '_')[[1]][1]
probs <- predict(models[[model_name]], new_data, type = 'prob')
roc <- roc(response = new_data$fraud,
predictor = probs$yes,
levels = levels(new_data$fraud))
plot(roc)
title(model_name)
}
}
end <- Sys.time()
end - start
script_time_end <- Sys.time()
script_time_end - script_time_start
options(repos = 'http://cran.rstudio.com/')
library(readxl)
library(plyr)
library(tidyverse)
library(caret)
library(GGally)
library(stringr)
library(rattle)
library(pROC)
library(ROCR)
library(iterators)
library('e1071')
library(randomForest)
library(rattle)
library(kernlab)
csv_path <- '/Users/jarad/Fake Folder/CSP/Recurring/Fraud and Chargeback Report/CSVs/Fraud Detection Data for R.xlsx'
main <- read_excel(csv_path)
colnames(main) <- str_replace_all(colnames(main), ' ', '_')
max <- summary(main$order_subtotal)['3rd Qu.']
ggplot(main, aes(x = order_subtotal, color = fraud)) +
geom_density() +
xlim(-25,500) +
ggtitle('Density Plot for Order Totals per Fraud Group')
head(main)
colnames(main)
head(main)
head(main, 2)
head(main, 1)
